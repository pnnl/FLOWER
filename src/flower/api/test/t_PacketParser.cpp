///////////////////////////////////////////////////////////////////////////////
// COPYRIGHT (C) 2008.  .  All Rights Reserved. 
//
// THIS FILE INITIALLY CREATED WITH:  
//     TEMPLATE NAME:  lang_cpp_test.template 
//     COMMAND NAME:   gensrc 
//
// ND file: $Id$ 
// _____________________________________________________________________________
// 
// PURPOSE OF TEST: 
//  [put a single sentence stating the purpost of this file 
//
// CODING CONVENTIONS: 
//    * Class names are CamelCase with first word upper case 
//    * Functions are camelCase with first word lower case 
//    * Function parameters are lower case with _ and have p_ prefix 
//    * Member variables always use 'this' pointer 
///////////////////////////////////////////////////////////////////////////////


// System Includes

// External Includes
#define BOOST_TEST_MODULE PacketParser
// Internal Includes
// Application Includes
#include "timeUtil.hpp"
#include "utility.hpp"
#include "packets/packets.hpp"
#include "PacketParser.hpp"


// Global Variables

int unsigned                 g_max_cache_size = 50;


void testOnFlowAddEvent(sharedFlow p_flow)
{
  ::g_flow = p_flow;
  testAddEvent();
  return;
}


struct PacketParserSuiteFixture
{
  FlowAddEvent       flow_add_event;
  PacketParser *     packet_parser;
  ByteArray *        empty_vector;
  ByteArray *        fake_vector;
  ByteArray *        incomplete_vector;
  sharedFlow         g_fake_flow;
  ObjectPool<Flow> * flow_pool;
  
  
  PacketParserSuiteFixture()
  {
    BOOST_TEST_MESSAGE("PacketParserSuite setup fixture");

    bool use_vlan          = true;
    bool skip_ipv4_packets = false;
    
    utility_init(); 

    // vectors that will be used to construct out test packets
    empty_vector      = new ByteArray(NULL,0); 
    fake_vector       = new ByteArray(NULL,0);
    incomplete_vector = new ByteArray(::g_incomplete_data,sizeof(::g_incomplete_data)); // this is a incomplete packet
    
    FlowKey    flow_key;
    sharedFlow fake_flow(new Flow(::g_FAKE));
    g_fake_flow       = fake_flow;
    g_fake_flow->forceFake(generateTimestamp(1));

    // "wire up" the events (set the callback functions)
    flow_add_event   += new FlowAddEvent::Static("add_event", testOnFlowAddEvent);
    
    sharedFlow flow   = generateFlow(true, generateTimestamp(1), 1);

    flow_pool         = new ObjectPool<Flow>(::g_max_cache_size, *flow);

    // Instantiate the PacketParser
    packet_parser     = new PacketParser(&flow_add_event, *flow_pool, ::g_timeout, getCacheForceout(), use_vlan, skip_ipv4_packets);

    return;
  }


  ~PacketParserSuiteFixture()
  {
    BOOST_TEST_MESSAGE("PacketParserSuite teardown fixture");
    
    delete(empty_vector);
    delete(fake_vector);
    delete(incomplete_vector);
    delete(packet_parser);
    delete(flow_pool);

    return;
  }
 
};


void checkStats(PacketParser * const p_packet_parser, int const p_tpr, int const p_tdpc, int const p_tdb)
{
  // check the packet statistics
  BOOST_CHECK_EQUAL(p_packet_parser->getTotalPacketsReceived(),    (u_int64_t) p_tpr);
  BOOST_CHECK_EQUAL(p_packet_parser->getTotalDroppedPacketCount(), (u_int64_t) p_tdpc);
  BOOST_CHECK_EQUAL(p_packet_parser->getTotalDroppedBytes(),       (u_int64_t) p_tdb);

  return;
}


void goodPacketFlow(PacketParser * const p_packet_parser, ByteArray * const p_good_packet_data)
{
  // Pre-condition:
  //   Need a good packet
  //   Need to create a good flow to compare against
  // Condition:
  //   Parse a packet
  //   The FlowAddEvent should have been called
  //   We should have created a good flow
  //   We should have some stats to compare against

  // Pre-condition: Create a good flow to compare against
  // This is ::g_flow
  map<string, Pair<string, sharedPacket> > packetMap(getPacketMap());

  int unsigned idx = p_packet_parser->getTotalPacketsReceived() + 1;

  for (map<string, Pair<string, sharedPacket> >::iterator itor = packetMap.begin(); itor != packetMap.end(); ++itor )
  {

    BOOST_TEST_MESSAGE("FILE: " + (*itor).first);

    // Condition: parse a packet
    p_packet_parser->onAddEvent((*itor).second.second.getValue());
  
    // Post-condition: was the FlowAddEvent called
    BOOST_CHECK_EQUAL(wasEventCalled(::g_add_event_called), true);

    // Post-condition: the flow generated was the same as the one we generated by hand
    BOOST_CHECK_EQUAL(::g_flow->createFlowString(), (*itor).second.first.getValue());

    // Post-condition: did we get the correct stats
    checkStats(p_packet_parser, idx, 0, 0);
    idx++;
  }

  return;
}


BOOST_FIXTURE_TEST_SUITE(PacketParserSuite, PacketParserSuiteFixture)


BOOST_AUTO_TEST_CASE(parse_a_good_packet_AND_create_a_flow)
{
  BOOST_TEST_MESSAGE("parse_a_good_packet_AND_create_a_flow");
  // Pre-condition:
  //   Need a good packet
  //   Need to create a good flow to compare against
  // Condition:
  //   Parse a packet
  // Post-condition:
  //   The PacketRemoveEvent should have been called
  //   The FlowAddEvent should have been called
  //   We should have created a good flow
  //   We should have some stats to compare against

  goodPacketFlow(packet_parser, &::g_good_packet_data);

  return;
}


BOOST_AUTO_TEST_CASE(parse_a_fake_packet)
{
  BOOST_TEST_MESSAGE("parse_a_fake_packet");
  // Pre-condition:
  //   Need a fake packet
  //   Need to create a fake flow to compare against
  // Condition:
  //   Parse a packet
  // Post-condition:
  //   The PacketRemoveEvent should have been called
  //   The FlowAddEvent should have been called
  //   We should have created a fake flow
  //   We should have some stats to compare against

  // Pre-condition: Create a fake flow to compare against
  // This is ::g_fake_flow

  // Pre-condition: Create a fake packet
  sharedPacket fake_packet(new Packet(::g_FAKE, *fake_vector, fake_vector->size(), fake_vector->size(), generateTimestamp(1), 0));

  // Condition: parse a packet
  cout << "DEVELOPER NOTE: There should be an CAUTION message that follows" << endl;
  packet_parser->onAddEvent(fake_packet);

  // Post-condition: was the FlowAddEvent called
  BOOST_CHECK_EQUAL(wasEventCalled(::g_add_event_called), true);


  // Post-condition: the flow generated was the same as the one we generated by hand
  BOOST_CHECK_EQUAL(::g_flow->compare(g_fake_flow), true);

  // Post-condition: did we get the correct stats
  checkStats(packet_parser, 0, 0, 0);

  return;
}


BOOST_AUTO_TEST_CASE(parse_an_empty_packet)
{
  BOOST_TEST_MESSAGE("parse_an_empty_packet");
  // Pre-condition:
  //   Need an empty packet
  // Condition:
  //   Parse a packet
  // Post-condition:
  //   The PacketRemoveEvent should have been called
  //   The FlowAddEvent      should have been called
  //   We should have some stats to compare against

  // Pre-condition: Create an empty packet
  sharedPacket empty_packet(new Packet(false, *empty_vector, empty_vector->size(), empty_vector->size(), generateTimestamp(1), 0));

  // Condition: parse a packet
  cout << "DEVELOPER NOTE: There should be an ERROR message that follows" << endl;
  packet_parser->onAddEvent(empty_packet);

  // Post-condition: the FlowAddEvent should not have been called
  BOOST_CHECK_EQUAL(wasEventCalled(::g_add_event_called), false);

  // Post-condition: did we get the correct stats
  checkStats(packet_parser, 1, 1, empty_vector->size());

  return;
}


BOOST_AUTO_TEST_CASE(parse_an_incomplete_packet)
{
  BOOST_TEST_MESSAGE("parse_an_incomplete_packet");
  // Pre-condition:
  //   Need a incomplete packet
  // Condition:
  //   Parse a packet
  // Post-condition:
  //   The PacketRemoveEvent should have been called
  //   The FlowAddEvent should NOT have been called
  //   We should have some stats to compare against

  // Pre-condition: Create a incomplete packet
  sharedPacket incomplete_packet(new Packet(false, *incomplete_vector, incomplete_vector->size(), incomplete_vector->size(), generateTimestamp(1), 0));

  // Condition: parse a packet
  cout << "DEVELOPER NOTE: There should be an ERROR message that follows" << endl;
  packet_parser->onAddEvent(incomplete_packet);

  // Post-condition: the FlowAddEvent should NOT be called
  BOOST_CHECK_EQUAL(wasEventCalled(::g_add_event_called), false);

  // Post-condition: did we get the correct stats
  checkStats(packet_parser, 1, 1, incomplete_vector->size());

  return;
}


BOOST_AUTO_TEST_SUITE_END()
