#!/usr/bin/perl -w

use strict;
use warnings;

use Date::Manip;
use File::Basename;
use Net::IP;


my $data_dir = $ENV{'ENSIP_HOME'} . "/src/flower/api/test/packets";


sub CalculateTimes($)
{
  my($orig_time)   = @_;
  # This is a local time converted by wireshark at the time and place where the text file was saved
  my($junk, $frac) = split(/\./, $orig_time);
  my $seconds      = UnixDate(ParseDate($orig_time), "%o");
  my $secs         = $seconds . '.' . $frac;
  my $duration     = '0.000000';
  my $time         = $orig_time;

  $time =~ s/-|\s|://g;
  $frac =~ s/^[0]+//;

  #return((join(',', $secs, $time, $duration), $seconds, $orig_time, $frac));
  return((join(',', $secs, $duration), $seconds, $orig_time, $frac));
}


sub IPv6_Format($)
{
  my($IPv6)  = @_;
  my $ip     =  new Net::IP($IPv6);
  my $result =  uc($ip->ip());
  $result    =~ s/://g;
  return($result);
}


sub IPv4_Format($)
{
  my($IPv4)  = @_;
  my @Octets = split(/\./, $IPv4);
  my $result = '';

  foreach my $byte (@Octets)
  {
    $result .= sprintf("%03u", $byte);
  }
  $result =~ s/^[0]+//;

  return($result);
}


sub getIpAddresses($$)
{
  my($version, $record) = @_;
  my @lines    = split(/\n/, $record);
  my $src_addr;
  my $dst_addr;

  foreach my $line (@lines)
  {
    if ($line =~ m/^\s+Source:\s+/)
    {
      ($src_addr) = $line =~ m/^\s+Source:\s+(.*?)\s+/;
      next;
    }
    if ($line =~ m/^\s+Destination:\s+/)
    {
      ($dst_addr) = $line =~ m/^\s+Destination:\s+(.*?)\s+/;
      next;
    }
  }
  
  if ($version == 4)
  {
    my $src_addr_ipv4 = IPv4_Format($src_addr);
    my $dst_addr_ipv4 = IPv4_Format($dst_addr);
    return("$src_addr_ipv4,$dst_addr_ipv4,,");
  }
  else
  {
    my $src_addr_ipv6 = IPv6_Format($src_addr);
    my $dst_addr_ipv6 = IPv6_Format($dst_addr);
    return(",,$src_addr_ipv6,$dst_addr_ipv6");
  }
}


sub getIpVersion($)
{
  my($record)  = @_;
  my @lines    = split(/\n/, $record);
  my $version  = 0;

  foreach my $line (@lines)
  {
    if ($line =~ m/^\s+Version:\s+\d+/)
    {
      ($version) = $line =~ m/^\s+Version:\s+(\d+)\s*/;
      last;
    }
  }
  return($version);
}


sub getIpOptions($)
{
  my($record)  = @_;
  my @lines    = split(/\n/, $record);
  my $options  = 0;

  foreach my $line (@lines)
  {
    if ($line =~ m/^\s+Options:\s+\(\d+/)
    {
      $options = 1;
      last;
    }
  }

  return($options);
}


sub getProtocol($)
{
  my($record)  = @_;
  my @lines    = split(/\n/, $record);
  my $protocol = '';

  foreach my $line (@lines)
  {
    if (($line =~ m/^\s+Protocol:.*?\(/) || ($line =~ m/^\s+Next header:.*?\(/))
    {
      ($protocol) = ($line =~ m/^\s+.*?:.*?\((0x[0-9a-f]+)\)/);
      $protocol   = hex($protocol);
      last;
    }
  }

  return($protocol);
}


sub getIcmpData($)
{
  my($record)  = @_;
  my @lines    = split(/\n/, $record);
  my $sequence = '';
  my $flags    = '';
  my $type     = '';
  my $code     = '';

  foreach my $line (@lines)
  {
    if ($line =~ m/^\s+Type:\s+\d+\s+/)
    {
      # Type: 8 
      # Code: 0
      ($type) = ($line =~ m/^\s+Type:\s+(\d+)\s+/);
    }
    if ($line =~ m/^\s+Code:\s+\d+\s*/)
    {
      ($code) = ($line =~ m/^\s+Code:\s+(\d+)\s*/);
    }
  }

  $type *= 256;
  $flags = $type + $code;
  $flags = sprintf("%04x", $flags);

  return(($flags, "+$flags"));
}


sub getTcpData($)
{
  my($record)  = @_;
  my @lines    = split(/\n/, $record);
  my $sequence = '';
  my $flags    = '';

  foreach my $line (@lines)
  {
    if ($line =~ m/^\s+Sequence\s+number:\s+\d+/)
    {
      # Sequence number: 511129658
      ($sequence) = ($line =~ m/^\s+Sequence\s+number:\s+(\d+)/);
    }
    if ($line =~ m/^\s+Flags:\s+0x\d+\s+/)
    {
      # Flags: 0x18 (PSH, ACK)
      ($flags) = ($line =~ m/^\s+Flags:\s+0x(\d+)\s+/);
    }
  }

  return(($flags, $sequence, $sequence, "+$flags"));
}


sub getData($$)
{
  my($line, $data) = @_;

  if ($data ne '')
  {
    $data .= ",\n";
  }
  my($hex, $temp_data, $garbage) = split(/\s{2,3}/, $line);
  $temp_data =~ s/\s/, 0x/g;
  my(@t) = split(/\s/, $temp_data);
  splice(@t, 8, 0, "\n   ") if (scalar(@t) > 8);
  $data .= '    0x' . join(' ', @t);

  return($data);
}


sub nonzeroJoin(@)
{
  my @fields = @_;
  my @result;

  foreach (@fields)
  {
    if (/^[0]{1,4}$/)  # 0 or 00 or 000 or 0000
    {
      push(@result, '');
    }
    else
    {
      push(@result, $_);
    }
  }
  return(join(',', @result));
}


sub processFiles()
{
  my @files;
  my $comment_str = "######################################################################";
  my $output      = "\n//\n//  DEVELOPER NOTE: This file was generated by " . basename($0) . "\n//\n\n\n";
  my @filenames;


  $output .= '#ifndef PACKETS_HPP'                                       . "\n";
  $output .= '#define PACKETS_HPP'                                       . "\n\n\n";
  $output .= '#include <map>'                                            . "\n";
  $output .= '#include <string>'                                         . "\n";
  $output .= '#include <boost/date_time/posix_time/posix_time.hpp>'      . "\n";
  $output .= '#include <boost/date_time/posix_time/time_formatters.hpp>' . "\n";
  $output .= '#include "EventTypes.hpp"'                                 . "\n";
  $output .= '#include "utility.hpp"'                                    . "\n";
  $output .= '#include "packets/Pair.hpp"'                               . "\n\n\n";
  $output .= 'using namespace std;'                                      . "\n";
  $output .= 'using namespace boost::posix_time;'                        . "\n\n\n";

  opendir(DH, $data_dir) || die("ERROR: Can't open data directory, $data_dir: $!");
  @files = sort(grep { !/IP_IPV6|IP_PIM|README/ } grep { /\.txt$/ } readdir(DH));
  #push(@files, "IP_UDP_DNS.txt");
  #push(@files, "IP_ICMP_ping.txt");
  #push(@files, "IP_TCP_HTTP.txt");
  closedir(DH);

  foreach my $file (@files)
  {
    my @records;
    my $data                 =    '';
    my $filename             = $file;
    my $line                 =    '';
    my $comment              =    '';
    my $vlan_num             =    '';
    my $current              =    '';
    my $ip_address           =    '';
    my $ip_version           =    '';
    my $times                =    '';
    my $timestamp            =    '';
    my $seconds              =    '';
    my $frac                 =    '';
    my $protocol             =    '';
    my $src_bytes            =   '0';
    my $dst_bytes            =   '0';
    my $src_payload          =  '##';
    my $dst_payload          =   '0';
    my $src_pkts             =   '1';
    my $dst_pkts             =   '0';
    my $src_ip_opts          =   '0';
    my $dst_ip_opts          =   '0';
    my $src_port             =   '';
    my $dst_port             =   '';
    my $src_icmp_flags       =    '';
    my $dst_icmp_flags       =    '';
    my $icmp_early_late_flag =    '';
    my $src_tcp_opts         =    '';
    my $dst_tcp_opts         =    '';
    my $src_tcp_flags        =    '';
    my $dst_tcp_flags        =    '';
    my $tcp_early_late_flag  =    '';
    my $src_first_tcp_ts     =    '';
    my $src_first_tcp_seq    =    '';
    my $dst_first_tcp_ts     =    '';
    my $dst_first_tcp_seq    =    '';
    my $src_last_tcp_seq     =    '';
    my $src_last_tcp_ts      =    '';
    my $dst_last_tcp_seq     =    '';
    my $dst_last_tcp_ts      =    '';
    my $src_tcp_retrans      =    '';
    my $dst_tcp_retrans      =    '';
    my $tunnel_saddr_v4      =    '';
    my $tunnel_daddr_v4      =    '';
    my $tunnel_saddr_v6      =    '';
    my $tunnel_daddr_v6      =    '';
    my $tunnel_proto         =    '';
    my $tunnel_src_port      =    '';
    my $tunnel_dst_port      =    '';
    my $fragment_type        =   'C';
    my $fragment             =   '0';
    my $result               =    '';

    my $eth_hdr_len          =  '14';
    my $eth_trailer_len      =   '0';
    my $eth_vlan_hdr_len     =   '0';
    my $ip_hdr_len           =   '0';
    my $proto_hdr_len        =   '0';

    $filename =~ s/\..*//;
    push(@filenames, $filename);

    open(FH, $file) || print("ERROR: Can't open file, $file: $!\n");
    while (<FH>)
    {
      next if (/^\s*$/);
      if (/^[0-9a-f]{4,4}\s+/)
      {
        $data = getData($_, $data);
      }
      elsif (/^\s+/)
      {
        s#\/\*##g;
        s#\*\/##g;
        $line .= $_;
      }
      else
      {
        # New Record line;
        push(@records, $line) if ($line ne '');
        $line = $_;
      }
    }
    push(@records, $line) if ($line ne '');   # Get the last record
    close(FH);

    $comment .= "#if 0\n/*\n";
    $comment .= "$comment_str\n";
    $comment .= "#   Data exported from: Wireshark\n";
    $comment .= "#   Data for File:      $file\n";
    $comment .= "$comment_str\n";

    my $length;
    foreach my $record (@records)
    {
      $comment .= $record;
      my @lines = split(/\n/, $record);
      foreach my $line (@lines)
      {
        if ($line =~ /^No\.\s+/)
        {
          ($times, $seconds, $timestamp, $frac) = getTimes($record);
        }
        elsif ($line =~ /^Frame\s+/)
        {
          ($src_bytes) = ($line =~ m/^Frame\s+\d+\s+\(\d+.*?(\d+)/);
        }
        elsif ($line =~ /^Ethernet\s+/)
        {
          $eth_trailer_len = getEtherTrailerLen($record);
        }
        elsif ($line =~ /^802\.1Q/)
        {
          ($vlan_num)       = ($line =~ m/^.*\s+(\d+)\s*$/);
          $eth_vlan_hdr_len = ("$vlan_num" ne '') ? 4 : 0;
          $eth_trailer_len  = getEtherTrailerLen($record);
        }
        elsif ($line =~ /^Internet\sProtocol/)
        {
          $ip_version     = getIpVersion($record);
          $ip_address     = getIpAddresses($ip_version, $record);
          $src_ip_opts    = getIpOptions($record);
          $protocol       = getProtocol($record);
          if (4 == $ip_version)
          {
            $ip_hdr_len   = getHdrLen($record);
          }
          else
          {
            $ip_hdr_len   = 40;
          }
          $proto_hdr_len  = getProtoHdrLen($protocol, $record);
        }
        elsif ($line =~ /^Internet\s+Control\s+Message\s+Protocol/)
        {
          ($src_icmp_flags, $icmp_early_late_flag) = getIcmpData($record);
          $dst_icmp_flags = '0000';
        }
        elsif ($line =~ /^\w+.*?Src\sPort:\s+/)
        {
          if ($line =~ /^Transmission\s+Control\s+Protocol,\s+/)
          {
            $proto_hdr_len = getHdrLen($record);
            ($src_tcp_flags, $src_first_tcp_seq, $src_last_tcp_seq, $tcp_early_late_flag) = getTcpData($record);
            $src_tcp_opts  =    0;
            $dst_tcp_opts  =    0;
            $dst_tcp_flags = '00';
          }
          ($src_port, $dst_port) = ($line =~ m/^\w+.*?,\s+Src\sPort:\s.*?\((\d+)\).*?Dst\sPort:\s.*?\((\d+)\)/);
        }
      }
    }

    my $tunnel_depth = '';
    my $anomaly      = '';

    if ($file =~ /truncated.txt/)
    {
      $anomaly = '00002000';
    }

    $src_payload  = $src_bytes - $eth_hdr_len - $eth_vlan_hdr_len - $eth_trailer_len - $ip_hdr_len - $proto_hdr_len;
    $src_bytes   -= $eth_trailer_len;

    $result = join (',', 0, 'site-name', nonzeroJoin($times, $vlan_num, $protocol, $ip_address, $src_payload, $dst_payload, $src_bytes, $dst_bytes, $src_pkts, $dst_pkts, $src_ip_opts, $dst_ip_opts, $src_port, $dst_port, $src_icmp_flags, $dst_icmp_flags, $icmp_early_late_flag, $src_tcp_opts, $dst_tcp_opts, $src_tcp_flags, $dst_tcp_flags, $tcp_early_late_flag, $src_first_tcp_ts, $src_first_tcp_seq, $dst_first_tcp_ts, $dst_first_tcp_seq, $src_last_tcp_ts, $src_last_tcp_seq, $dst_last_tcp_ts, $dst_last_tcp_seq, $src_tcp_retrans, $dst_tcp_retrans, $tunnel_depth, $tunnel_saddr_v4, $tunnel_daddr_v4, $tunnel_saddr_v6, $tunnel_daddr_v6, $tunnel_proto, $tunnel_src_port, $tunnel_dst_port, $fragment_type, $fragment, $anomaly));

    $comment.= "$comment_str\n";
    $output .= "$comment*/\n#endif\n\n";
    $output .= "string get_$filename" . '_str(void)'                     . "\n";
    $output .= '{'                                                       . "\n";
    $output .= "  string $filename" . '_str = "' . $result . '";'        . "\n\n";
    $output .= "  return($filename" . '_str);'                           . "\n";
    $output .= '}'                                                       . "\n\n\n";
    $output .= "sharedPacket get_$filename" . '_pkt(void)'               . "\n";
    $output .= '{'                                                       . "\n";
    $output .= '  string ts("' . $timestamp . '");'                      . "\n";
    $output .= '  ptime  pt(time_from_string(ts));'                      . "\n";
    $output .= '  time_duration diff = pt - getEpochUTC();'              . "\n\n";
    my $count  = ($data =~ tr/,//) + 1;
    $output .= '  static char unsigned data[' . $count . '] = ' . "\n  {\n$data\n  };\n\n";
    $output .= '  sharedPacket packet(new Packet(false));' . "\n";
    $output .= '  struct pcap_pkthdr packet_header;' . "\n";
    $output .= '  packet_header.caplen     = ' . $count   . ";\n";
    $output .= '  packet_header.len        = ' . $count   . ";\n";
    $output .= '  packet_header.ts.tv_sec  = ' . $seconds . ";\n";
    $output .= '  packet_header.ts.tv_usec = ' . $frac    . ";\n";
    $output .= '  packet->assign(&packet_header, data)'   . ";\n\n";
    $output .= "  return(packet);\n";
    $output .= '}' . "\n\n\n";
  }

  my $idx  = 'A';
  $output .= 'map<string, Pair<string, sharedPacket> > getPacketMap(void)' . "\n";
  $output .= '{' . "\n";
  $output .= '  map<string, Pair<string, sharedPacket> > packet_map;' . "\n";
  foreach (@filenames)
  {
    $output .= '  Pair<string, sharedPacket> ' . $idx . '(get_' . $_ . '_str(), get_' . $_ . '_pkt(), true);' . "\n";
    $output .= '  packet_map.insert(make_pair("' . $_ . '", ' . $idx . '));' . "\n";
    $idx++;
  }
  $output .= "\n" . '  return(packet_map);' . "\n";
  $output .= '}' . "\n\n\n";
  $output .= '#endif' . "\n"; 
  return($output);
}


sub getEtherTrailerLen($)
{
  my($record)         = @_;
  my @num_lines       = split(/\n/, $record);
  my $eth_trailer_len = 0;

  foreach my $num_line (@num_lines)
  {
    if ($num_line =~ m/^\s+Trailer:\s+\d+/)
    {
      ($eth_trailer_len) = ($num_line =~ m/^\s+Trailer:\s+(\d+)/);
      $eth_trailer_len   = length($eth_trailer_len) / 2;
    }
  }

  return($eth_trailer_len);
}


sub getTimes($)
{
  my($record) = @_;
  my @num_lines          = split(/\n/, $record);
  my $dateTimeExpression = '\d{4,4}-\d{2,2}-\d{2,2}\s\d{2,2}:\d{2,2}:\d{2,2}.\d{6,6}';

  foreach my $num_line (@num_lines)
  {
    if ($num_line =~ m/^\s+\d+\s+$dateTimeExpression\s+/)
    {
      my($timestamp) = ($num_line =~ m/^\s+\d+\s+($dateTimeExpression)\s+/);
      return(CalculateTimes($timestamp));
    }
  }

  return("ERROR_NO_TIME");
}


sub getProtoHdrLen($$)
{
  my($protocol, $record) = @_;
  my $proto_hdr_len      = 0;
  my %hdrSizes           = (
                             '1'  => 8,
                             '17' => 8,
                             '58' => 8,
                           );

#print("PROTOCOL:$protocol:\n");
  if (exists($hdrSizes{$protocol}))
  {
    $proto_hdr_len = $hdrSizes{$protocol};
  }

  return($proto_hdr_len);
}


sub getHdrLen($)
{
  my($record) = @_;
  my @num_lines = split(/\n/, $record);
  my $hdr_len   = 0;

  foreach my $num_line (@num_lines)
  {
    if ($num_line =~ m/^\s+Header\s+length:\s+\d+/)
    {
      ($hdr_len) = ($num_line =~ m/^\s+Header\s+length:\s+(\d+)/);
      last;
    }
  }

  return($hdr_len);
}


sub init()
{
  Date_Init("TZ=GMT"); # this is needed for Windows
  chdir($data_dir) || die("ERROR: Can't chdir to data directory, $data_dir: $!");

  return;
}


sub doWork()
{
  #my $good = 'string        g_IP_UDP_DNS_str = "1226297301.053798,20081110060821.053798,0.000000,pnnl_dev,,17,140221251250,192012094030,00000000000000000000FFFF8CDDFBFA,00000000000000000000FFFFC00C5E1E,53,0,95,0,1,0,0,0,48506,53,,,,,,,,,,,,,,,,,,,,C,0";';
  #print("$good\n");

  my $output      = processFiles();
  my $output_file = "packets.hpp";
  open(FH, ">$output_file") || die("ERROR: Can't open file, $output_file: $!");
  print(FH $output);
  close(FH);

  return;
}


########################################################################################
#  Main
########################################################################################

init();
doWork();

exit(0);
